name: Check PR Lines Changed
description: 'Checks the number of lines changed in a PR and manages size labels accordingly.'

inputs:
  max-lines:
    description: 'Maximum allowed total lines changed'
    required: false
    default: '1000'
  base-ref:
    description: 'Default base branch to compare against (if not running on a PR)'
    required: false
    default: 'main'
  ignore-patterns:
    description: 'Regex pattern for files to ignore when calculating changes'
    required: false
    default: '(\.lock$)'
  xs-max-size:
    description: 'Maximum lines for XS size'
    required: false
    default: '10'
  s-max-size:
    description: 'Maximum lines for S size'
    required: false
    default: '100'
  m-max-size:
    description: 'Maximum lines for M size'
    required: false
    default: '500'
  l-max-size:
    description: 'Maximum lines for L size'
    required: false
    default: '1000'

runs:
  using: composite
  steps:
    - name: Checkout code
      uses: actions/checkout@v6

    - name: Calculate changed lines
      id: line-count
      env:
        BASE_BRANCH: ${{ github.event.pull_request.base.ref || inputs.base-ref }}
        IGNORE_PATTERNS: ${{ inputs.ignore-patterns }}
      shell: bash
      run: |
        set -e

        echo "Using base branch: $BASE_BRANCH"

        # Instead of a full fetch, perform incremental fetches at increasing depth
        # until the merge-base between origin/<BASE_BRANCH> and HEAD is present.
        fetch_with_depth() {
          local depth=$1
          echo "Attempting to fetch with depth $depth..."
          git fetch --depth="$depth" origin "$BASE_BRANCH"
        }

        depths=(1 10 100)
        merge_base_found=false

        for d in "${depths[@]}"; do
          fetch_with_depth "$d"
          if git merge-base "origin/$BASE_BRANCH" HEAD > /dev/null 2>&1; then
            echo "Merge base found with depth $d."
            merge_base_found=true
            break
          else
            echo "Merge base not found with depth $d, increasing depth..."
          fi
        done

        # If we haven't found the merge base with shallow fetches, unshallow the repo.
        if [ "$merge_base_found" = false ]; then
          echo "Could not find merge base with shallow fetches, fetching full history..."
          git fetch --unshallow origin "$BASE_BRANCH" || git fetch origin "$BASE_BRANCH"
        fi

        # Calculate additions and deletions across all changes between the base and HEAD,
        # filtering out files matching the ignore pattern.
        additions=$(git diff "origin/$BASE_BRANCH"...HEAD --numstat | grep -Ev "$IGNORE_PATTERNS" | awk '{add += $1} END {print add+0}')
        deletions=$(git diff "origin/$BASE_BRANCH"...HEAD --numstat | grep -Ev "$IGNORE_PATTERNS" | awk '{del += $2} END {print del+0}')
        total=$((additions + deletions))

        echo "Additions: $additions, Deletions: $deletions, Total: $total"
        {
          echo "lines-changed=$total"
          echo "additions=$additions"
          echo "deletions=$deletions"
        } >> "$GITHUB_OUTPUT"

    - name: Check line count limit
      uses: actions/github-script@v7
      env:
        LINES_CHANGED: ${{ steps.line-count.outputs.lines-changed }}
        ADDITIONS: ${{ steps.line-count.outputs.additions }}
        DELETIONS: ${{ steps.line-count.outputs.deletions }}
        MAX_LINES: ${{ inputs.max-lines }}
        XS_MAX_SIZE: ${{ inputs.xs-max-size }}
        S_MAX_SIZE: ${{ inputs.s-max-size }}
        M_MAX_SIZE: ${{ inputs.m-max-size }}
        L_MAX_SIZE: ${{ inputs.l-max-size }}
      with:
        script: |
          const {
            LINES_CHANGED,
            ADDITIONS,
            DELETIONS,
            MAX_LINES,
            XS_MAX_SIZE,
            S_MAX_SIZE,
            M_MAX_SIZE,
            L_MAX_SIZE,
          } = process.env;

          const total = parseInt(LINES_CHANGED, 10) || 0;
          const additions = parseInt(ADDITIONS, 10) || 0;
          const deletions = parseInt(DELETIONS, 10) || 0;

          // Thresholds from inputs with fallback to defaults
          const maxLines = parseInt(MAX_LINES, 10) || 1000;
          const xsMaxSize = parseInt(XS_MAX_SIZE, 10) || 10;
          const sMaxSize = parseInt(S_MAX_SIZE, 10) || 100;
          const mMaxSize = parseInt(M_MAX_SIZE, 10) || 500;
          const lMaxSize = parseInt(L_MAX_SIZE, 10) || 1000;

          // Print summary
          console.log('Summary:');
          console.log(`  - Additions: ${additions}`);
          console.log(`  - Deletions: ${deletions}`);
          console.log(`  - Total: ${total}`);
          console.log(`  - Limit: ${maxLines}`);

          // Determine size label based on configured criteria
          let sizeLabel = '';
          if (total <= xsMaxSize) {
            sizeLabel = 'size-XS';
          } else if (total <= sMaxSize) {
            sizeLabel = 'size-S';
          } else if (total <= mMaxSize) {
            sizeLabel = 'size-M';
          } else if (total <= lMaxSize) {
            sizeLabel = 'size-L';
          } else {
            sizeLabel = 'size-XL';
          }

          console.log(`  - Size category: ${sizeLabel}`);

          // Manage PR labels
          const owner = context.repo.owner;
          const repo = context.repo.repo;
          const issue_number = context.payload.pull_request.number;

          try {
            const existingSizeLabels = ['size-XS', 'size-S', 'size-M', 'size-L', 'size-XL'];

            // Get current labels
            const currentLabels = await github.rest.issues.listLabelsOnIssue({
              owner,
              repo,
              issue_number
            });

            const currentLabelNames = currentLabels.data.map(l => l.name);

            // Build new label set: keep non-size labels and add the new size label
            const newLabels = currentLabelNames
              .filter(name => !existingSizeLabels.includes(name))  // Remove all size labels
              .concat(sizeLabel);  // Add the correct size label

            // Check if labels need updating
            const currentSizeLabel = currentLabelNames.find(name => existingSizeLabels.includes(name));
            if (currentSizeLabel === sizeLabel && currentLabelNames.length === newLabels.length) {
              console.log(`✅ Correct label '${sizeLabel}' already present, no changes needed`);
            } else {
              // Update all labels in a single API call
              await github.rest.issues.setLabels({
                owner,
                repo,
                issue_number,
                labels: newLabels
              });

              if (currentSizeLabel && currentSizeLabel !== sizeLabel) {
                console.log(`  - Replaced '${currentSizeLabel}' with '${sizeLabel}'`);
              } else if (!currentSizeLabel) {
                console.log(`✅ Added '${sizeLabel}' label to PR #${issue_number}`);
              } else {
                console.log(`✅ Updated labels for PR #${issue_number}`);
              }
            }
          } catch (error) {
            console.log(`⚠️  Could not manage labels: ${error.message}`);
          }

          // Check if exceeds limit
          if (total > maxLines) {
            console.log(`❌ Error: Total changed lines (${total}) exceed the limit of ${maxLines}.`);
            process.exit(1);
          } else {
            console.log(`✅ Success: Total changed lines (${total}) are within the limit of ${maxLines}.`);
          }
