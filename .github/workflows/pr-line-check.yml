name: Check PR Lines Changed

on:
  workflow_call:
    inputs:
      max_lines:
        description: 'Maximum allowed total lines changed'
        required: false
        type: number
        default: 1000
      base_ref:
        description: 'Default base branch to compare against (if not running on a PR)'
        required: false
        type: string
        default: 'main'
      ignore_patterns:
        description: 'Regex pattern for files to ignore when calculating changes'
        required: false
        type: string
        default: '(\.lock$)'
      xs_max_size:
        description: 'Maximum lines for XS size'
        required: false
        type: number
        default: 10
      s_max_size:
        description: 'Maximum lines for S size'
        required: false
        type: number
        default: 100
      m_max_size:
        description: 'Maximum lines for M size'
        required: false
        type: number
        default: 500
      l_max_size:
        description: 'Maximum lines for L size'
        required: false
        type: number
        default: 1000

jobs:
  check-lines:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine base branch
        id: get-base-branch
        run: |
          # Use the PR base branch if available; otherwise use the default input.
          if [ -n "${{ github.event.pull_request.base.ref }}" ]; then
            echo "Using PR base branch: ${{ github.event.pull_request.base.ref }}"
            echo "base_branch=${{ github.event.pull_request.base.ref }}" >> "$GITHUB_OUTPUT"
          else
            echo "Using default base branch: ${{ inputs.base_ref }}"
            echo "base_branch=${{ inputs.base_ref }}" >> "$GITHUB_OUTPUT"
          fi

      - name: Calculate changed lines
        id: line_count
        run: |
          set -e

          BASE_BRANCH="${{ steps.get-base-branch.outputs.base_branch }}"
          echo "Using base branch: $BASE_BRANCH"

          # Instead of a full fetch, perform incremental fetches at increasing depth
          # until the merge-base between origin/<BASE_BRANCH> and HEAD is present.
          fetch_with_depth() {
            local depth=$1
            echo "Attempting to fetch with depth $depth..."
            git fetch --depth="$depth" origin "$BASE_BRANCH"
          }

          depths=(1 10 100)
          merge_base_found=false

          for d in "${depths[@]}"; do
            fetch_with_depth "$d"
            if git merge-base "origin/$BASE_BRANCH" HEAD > /dev/null 2>&1; then
              echo "Merge base found with depth $d."
              merge_base_found=true
              break
            else
              echo "Merge base not found with depth $d, increasing depth..."
            fi
          done

          # If we haven't found the merge base with shallow fetches, unshallow the repo.
          if [ "$merge_base_found" = false ]; then
            echo "Could not find merge base with shallow fetches, fetching full history..."
            git fetch --unshallow origin "$BASE_BRANCH" || git fetch origin "$BASE_BRANCH"
          fi

           # Set the ignore pattern from input
          ignore_pattern="${{ inputs.ignore_patterns }}"

          # Calculate additions and deletions across all changes between the base and HEAD,
          # filtering out files matching the ignore pattern.
          additions=$(git diff "origin/$BASE_BRANCH"...HEAD --numstat | grep -Ev "$ignore_pattern" | awk '{add += $1} END {print add+0}')
          deletions=$(git diff "origin/$BASE_BRANCH"...HEAD --numstat | grep -Ev "$ignore_pattern" | awk '{del += $2} END {print del+0}')
          total=$((additions + deletions))

          echo "Additions: $additions, Deletions: $deletions, Total: $total"
          {
            echo "lines_changed=$total"
            echo "additions=$additions"
            echo "deletions=$deletions"
          } >> "$GITHUB_OUTPUT"

      - name: Check line count limit
        uses: actions/github-script@v7
        with:
          script: |
            const total = parseInt('${{ steps.line_count.outputs.lines_changed }}') || 0;
            const additions = parseInt('${{ steps.line_count.outputs.additions }}') || 0;
            const deletions = parseInt('${{ steps.line_count.outputs.deletions }}') || 0;
            const maxLines = parseInt('${{ inputs.max_lines }}');

            // Size thresholds from inputs
            const xsMaxSize = parseInt('${{ inputs.xs_max_size }}');
            const sMaxSize = parseInt('${{ inputs.s_max_size }}');
            const mMaxSize = parseInt('${{ inputs.m_max_size }}');
            const lMaxSize = parseInt('${{ inputs.l_max_size }}');

            // Print summary
            console.log('Summary:');
            console.log(`  - Additions: ${additions}`);
            console.log(`  - Deletions: ${deletions}`);
            console.log(`  - Total: ${total}`);
            console.log(`  - Limit: ${maxLines}`);

            // Determine size label based on configured criteria
            let sizeLabel = '';
            if (total <= xsMaxSize) {
              sizeLabel = 'size-XS';
            } else if (total <= sMaxSize) {
              sizeLabel = 'size-S';
            } else if (total <= mMaxSize) {
              sizeLabel = 'size-M';
            } else if (total <= lMaxSize) {
              sizeLabel = 'size-L';
            } else {
              sizeLabel = 'size-XL';
            }

            console.log(`  - Size category: ${sizeLabel}`);

            // Manage PR labels
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = context.payload.pull_request.number;

            try {
              const existingSizeLabels = ['size-XS', 'size-S', 'size-M', 'size-L', 'size-XL'];
              
              // Get current labels
              const currentLabels = await github.rest.issues.listLabelsOnIssue({
                owner,
                repo,
                issue_number
              });
              
              const currentLabelNames = currentLabels.data.map(l => l.name);
              const currentSizeLabels = currentLabelNames.filter(name => existingSizeLabels.includes(name));
              
              // Check if we already have the correct label
              if (currentSizeLabels.length === 1 && currentSizeLabels[0] === sizeLabel) {
                console.log(`✅ Correct label '${sizeLabel}' already present, no changes needed`);
              } else {
                // Remove only the size labels that need to be removed
                for (const label of currentSizeLabels) {
                  if (label !== sizeLabel) {
                    await github.rest.issues.removeLabel({
                      owner,
                      repo,
                      issue_number,
                      name: label
                    });
                    console.log(`  - Removed label: ${label}`);
                  }
                }
                
                // Add the new label only if it's not already present
                if (!currentLabelNames.includes(sizeLabel)) {
                  await github.rest.issues.addLabels({
                    owner,
                    repo,
                    issue_number,
                    labels: [sizeLabel]
                  });
                  console.log(`✅ Added '${sizeLabel}' label to PR #${issue_number}`);
                } else {
                  console.log(`✅ Label '${sizeLabel}' already present`);
                }
              }
            } catch (error) {
              console.log(`⚠️  Could not manage labels: ${error.message}`);
            }

            // Check if exceeds limit
            if (total > maxLines) {
              console.log(`❌ Error: Total changed lines (${total}) exceed the limit of ${maxLines}.`);
              process.exit(1);
            } else {
              console.log(`✅ Success: Total changed lines (${total}) are within the limit of ${maxLines}.`);
            }
